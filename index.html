<!DOCTYPE html>
<html>
<head>
  <title>DNREC Shellfish Survey Map</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    #map { height: 90vh; width: 100%; }

    .zone-control {
      background: #fff;
      padding: 10px 12px;
      border-radius: 8px;
      box-shadow: 0 1px 6px rgba(0,0,0,0.25);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 13px;
      line-height: 1.25;
      max-height: 260px;
      overflow: auto;
      min-width: 210px;
    }
    .zone-control .title {
      font-weight: 700;
      margin-bottom: 6px;
      font-size: 13px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    .zone-control .title button {
      border: 1px solid #ddd;
      background: #f7f7f7;
      border-radius: 6px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 12px;
    }
    .zone-control .title button:hover { background: #eee; }
    .zone-control ol { margin: 0; padding-left: 18px; }
    .zone-control li { margin: 2px 0; }
    .zone-link {
      cursor: pointer;
      text-decoration: underline;
      color: #1f78b4;
      user-select: none;
    }
    .zone-link.active {
      font-weight: 700;
      color: #0b4f8a;
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    // If you have many markers, this helps performance
    var map = L.map('map', { preferCanvas: true }).setView([39.0, -75.45], 9);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Zone list control
    var zoneControl = L.control({ position: 'topright' });

    zoneControl.onAdd = function () {
      var div = L.DomUtil.create('div', 'zone-control');
      div.innerHTML =
        '<div class="title">' +
          '<span>Clamming Zones and Sites</span>' +
          '<button id="showAllBtn" type="button">Show all</button>' +
        '</div>' +
        '<ol id="zoneList"></ol>';

      L.DomEvent.disableClickPropagation(div);
      L.DomEvent.disableScrollPropagation(div);
      return div;
    };

    zoneControl.addTo(map);

    function setActiveZoneInList(zoneName) {
      document.querySelectorAll('.zone-link').forEach(function (el) {
        el.classList.toggle('active', el.dataset.zone === zoneName);
      });
    }
    function clearActiveZoneInList() {
      document.querySelectorAll('.zone-link').forEach(function (el) {
        el.classList.remove('active');
      });
    }

    // Styles
    function polygonDefaultStyle() { return { color: "#1f78b4", weight: 2, fillOpacity: 0.4 }; }
    function polygonHighlightStyle() { return { color: "#ff7f00", weight: 4, fillOpacity: 0.35 }; }
    function pointDefaultStyle() { return { radius: 10, fillColor: "#e31a1c", color: "#fff", weight: 2, fillOpacity: 1 }; }
    function pointHighlightStyle() { return { radius: 12, fillColor: "#ff7f00", color: "#fff", weight: 2, fillOpacity: 1 }; }

    // IMPORTANT: make sure the filename matches what you generated
    fetch("data/clamming_polygons.geojson")
      .then(function (response) {
        if (!response.ok) throw new Error("Failed to load GeoJSON: " + response.status);
        return response.json();
      })
      .then(function (data) {

        var polygonLayersByZone = new Map();
        var pointLayersByZone = new Map();
        var allBounds = null;

        function addToMapList(mapObj, key, layer) {
          if (!mapObj.has(key)) mapObj.set(key, []);
          mapObj.get(key).push(layer);
        }

        L.geoJSON(data, {
          style: function (feature) {
            if (feature.geometry.type === "Polygon" || feature.geometry.type === "MultiPolygon") {
              return polygonDefaultStyle();
            }
          },
          pointToLayer: function (feature, latlng) {
            return L.circleMarker(latlng, pointDefaultStyle());
          },
          onEachFeature: function (feature, layer) {
            var p = feature.properties || {};
            var zone = (p.zone_name != null) ? String(p.zone_name) : "Unknown";

            // update overall bounds
            try {
              if (layer.getBounds) {
                allBounds = allBounds ? allBounds.extend(layer.getBounds()) : layer.getBounds();
              } else if (layer.getLatLng) {
                var ll = layer.getLatLng();
                allBounds = allBounds ? allBounds.extend(ll) : L.latLngBounds([ll, ll]);
              }
            } catch (e) {}

            if (feature.geometry.type === "Polygon" || feature.geometry.type === "MultiPolygon") {
              addToMapList(polygonLayersByZone, zone, layer);

              var popup = "<b>" + (p.zone_name ?? "") + "</b><br>" +
                          "Site: " + (p.site_name ?? "");
              if (p.polygon_id != null) popup += "<br>Polygon: " + p.polygon_id;

              layer.bindPopup(popup);
            }

            if (feature.geometry.type === "Point") {
              addToMapList(pointLayersByZone, zone, layer);

              layer.bindPopup(
                "<b>" + (p.zone_name ?? "") + "</b><br>" +
                "Site: " + (p.site_name ?? "")
              );
            }
          }
        }).addTo(map);

        // Zone list
        var zoneSet = new Set([ ...polygonLayersByZone.keys(), ...pointLayersByZone.keys() ]);
        var zonesSorted = Array.from(zoneSet).sort(function (a, b) { return a.localeCompare(b); });

        var listEl = document.getElementById('zoneList');
        listEl.innerHTML = zonesSorted.map(function (z) {
          return '<li><span class="zone-link" data-zone="' + z.replace(/"/g, '&quot;') + '">' + z + '</span></li>';
        }).join('');

        function resetAllStyles() {
          polygonLayersByZone.forEach(function (layers) { layers.forEach(function (lyr) { lyr.setStyle(polygonDefaultStyle()); }); });
          pointLayersByZone.forEach(function (layers) { layers.forEach(function (lyr) { lyr.setStyle(pointDefaultStyle()); }); });
        }

        function focusZone(zoneName) {
          resetAllStyles();
          setActiveZoneInList(zoneName);

          var bounds = null;

          (polygonLayersByZone.get(zoneName) || []).forEach(function (lyr) {
            lyr.setStyle(polygonHighlightStyle());
            var b = lyr.getBounds();
            bounds = bounds ? bounds.extend(b) : b;
          });

          (pointLayersByZone.get(zoneName) || []).forEach(function (lyr) {
            lyr.setStyle(pointHighlightStyle());
            var ll = lyr.getLatLng();
            bounds = bounds ? bounds.extend(ll) : L.latLngBounds([ll, ll]);
          });

          if (bounds) map.fitBounds(bounds.pad(0.15));
        }

        listEl.addEventListener('click', function (e) {
          var target = e.target;
          if (target && target.classList.contains('zone-link')) {
            focusZone(target.dataset.zone);
          }
        });

        document.getElementById('showAllBtn').addEventListener('click', function () {
          resetAllStyles();
          clearActiveZoneInList();
          if (allBounds) map.fitBounds(allBounds.pad(0.10));
        });

        if (allBounds) map.fitBounds(allBounds.pad(0.10));
      })
      .catch(function (err) {
        console.error(err);
        alert("Could not load the GeoJSON. Check the console for details.\n\n" + err.message);
      });
  </script>
</body>
</html>
